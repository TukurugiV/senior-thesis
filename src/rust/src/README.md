# main.rs

IMUセンサーデータを受信し、クォータニオンベースの姿勢推定を行うRustプログラム。

## 概要

シリアルポート経由でIMUセンサーデータ（ジャイロスコープ・加速度計）を受信し、コンプリメンタリフィルタを用いてリアルタイムに姿勢（向き）を計算するプログラム。計算結果はクォータニオン形式で標準出力に、回転ベクトル形式でUDP経由でUnityに送信される。

## ビルドと実行

```bash
# ビルド
cargo build --release

# 実行（自動ポート選択）
./target/release/imu_orientation_rust

# 実行（ポート指定）
./target/release/imu_orientation_rust COM8
```

## 依存クレート

```toml
[dependencies]
serialport = "4.3"    # シリアルポート通信
anyhow = "1.0"        # エラーハンドリング
socket2 = "0.5"       # UDPソケット通信
```

## 定数定義

```rust
const PACKET_SIZE: usize = 24;      // パケットサイズ（バイト）
const TARGET_FPS: f64 = 120.0;      // 目標フレームレート
const DT: f64 = 1.0 / TARGET_FPS;   // 時間刻み（初期値）
const DEG2RAD: f64 = PI / 180.0;    // 度からラジアンへの変換係数
```

## 通信設定

### シリアル通信

| パラメータ | 設定値 |
|------------|--------|
| ボーレート | 115200 bps |
| タイムアウト | 200 ms |
| DTR/RTS | 有効 |

### UDP通信

| 用途 | アドレス |
|------|----------|
| Unity へのデータ送信 | 127.0.0.1:50005 |
| コマンド受信 | 127.0.0.1:50006 |

## パケット仕様

### 入力パケット（ImuPacket）

24バイトのバイナリパケット:

| オフセット | サイズ | 型 | 内容 |
|------------|--------|------|------|
| 0-1 | 2 | u8 | ヘッダ (0x55, 0xAA) |
| 2-5 | 4 | u32 | シーケンス番号 |
| 6-9 | 4 | u32 | リクエストシーケンス番号 |
| 10-11 | 2 | i16 | ジャイロX |
| 12-13 | 2 | i16 | ジャイロY |
| 14-15 | 2 | i16 | ジャイロZ |
| 16-17 | 2 | i16 | 加速度X |
| 18-19 | 2 | i16 | 加速度Y |
| 20-21 | 2 | i16 | 加速度Z |
| 22-23 | 2 | u16 | チェックサム |

## データスケーリング

### ジャイロスコープ

```rust
fn gyro_to_dps(gx: i16, gy: i16, gz: i16) -> (f64, f64, f64) {
    let scale = 16.384_f64;  // LSB/dps (±2000 dps レンジ)
    (gx as f64 / scale, gy as f64 / scale, gz as f64 / scale)
}
```

### 加速度計

```rust
fn accel_to_g(ax: i16, ay: i16, az: i16) -> (f64, f64, f64) {
    let scale = 8192.0_f64;  // LSB/g (±4 g レンジ)
    (ax as f64 / scale, ay as f64 / scale, az as f64 / scale)
}
```

## クォータニオン（Quaternion）

姿勢を表現するための四元数構造体。

### 構造体定義

```rust
struct Quaternion {
    w: f64,  // スカラー成分
    x: f64,  // ベクトル成分 i
    y: f64,  // ベクトル成分 j
    z: f64,  // ベクトル成分 k
}
```

### 主要メソッド

| メソッド | 説明 |
|----------|------|
| `identity()` | 単位クォータニオン (1, 0, 0, 0) を返す |
| `normalize()` | 正規化（大きさを1にする） |
| `mul(other)` | クォータニオン乗算（回転の合成） |
| `from_euler(roll, pitch, yaw)` | オイラー角からクォータニオン生成 |
| `to_euler()` | クォータニオンからオイラー角へ変換 |
| `to_rotation_vectors()` | 回転行列のX軸・Y軸ベクトルを取得 |
| `integrate_gyro(gx, gy, gz, dt)` | 角速度を時間積分 |
| `nlerp(other, t)` | 正規化線形補間 |

### オイラー角変換

Z-Y-X（ヨー・ピッチ・ロール）順序を採用。

```rust
// オイラー角 → クォータニオン
fn from_euler(roll: f64, pitch: f64, yaw: f64) -> Self

// クォータニオン → オイラー角
fn to_euler(self) -> (f64, f64, f64)  // (roll, pitch, yaw)
```

## 姿勢推定アルゴリズム

### コンプリメンタリフィルタ

ジャイロスコープと加速度計のデータを融合して安定した姿勢推定を行う。

```rust
fn update_orientation_quat(
    q: &mut Quaternion,      // 現在の姿勢
    gx_dps, gy_dps, gz_dps,  // ジャイロ (度/秒)
    ax_g, ay_g, az_g,        // 加速度 (G)
    dt: f64,                 // 時間刻み
    alpha: f64,              // フィルタ係数 (0.98)
)
```

**処理フロー:**

1. ジャイロデータを rad/s に変換
2. ジャイロで姿勢を積分 (`q_gyro`)
3. 加速度のノルムをチェック（0.5 < norm < 1.5 のとき有効）
4. 加速度からロール・ピッチを計算
5. ヨーはジャイロ積分結果を使用
6. nlerp で補間（α = 0.98 でジャイロ優先）

### 加速度からのチルト推定

```rust
fn attitude_from_accel(ax: f64, ay: f64, az: f64) -> (f64, f64) {
    let roll = ay.atan2(az);
    let pitch = (-ax).atan2((ay * ay + az * az).sqrt());
    (roll, pitch)
}
```

## キャリブレーション

### 起動時キャリブレーション

プログラム起動時に2秒間のキャリブレーションを実行。

```rust
fn calibrate(port: &mut dyn SerialPort, duration_sec: f64)
    -> Result<(Quaternion, (f64, f64, f64))>
```

**処理内容:**
1. 指定時間（2秒）IMUデータを収集
2. ジャイロバイアス（オフセット）を計算
3. 加速度から初期姿勢（ロール・ピッチ）を推定
4. 初期クォータニオンとジャイロバイアスを返す

### 途中キャリブレーション

実行中に標準入力またはUDPで "CALIBRATE" コマンドを受信すると再キャリブレーションを実行。

## 出力形式

### 標準出力（Python向け）

```
# seq,request_seq,qw,qx,qy,qz
DATA_Q,1234,567,0.707106781,0.000000000,0.707106781,0.000000000
```

| フィールド | 説明 |
|------------|------|
| seq | 内部シーケンス番号 |
| request_seq | リクエストシーケンス番号（パルス同期用） |
| qw, qx, qy, qz | クォータニオン成分 |

### UDP出力（Unity向け）

```
DATA,1234,567,1.0,0.0,0.0,0.0,1.0,0.0
```

| フィールド | 説明 |
|------------|------|
| seq | 内部シーケンス番号 |
| request_seq | リクエストシーケンス番号 |
| ex_x, ex_y, ex_z | 回転行列のX軸方向ベクトル |
| ey_x, ey_y, ey_z | 回転行列のY軸方向ベクトル |

## 主要関数

### `main()`

メインエントリーポイント。

1. コマンドライン引数からポート名取得（または自動選択）
2. シリアルポートを開く
3. 起動時キャリブレーション実行
4. UDP通信設定
5. 標準入力監視スレッド起動
6. メインループ開始

### `read_packet()`

シリアルポートから1パケットを読み取る。

```rust
fn read_packet(port: &mut dyn SerialPort) -> Result<Option<ImuPacket>>
```

- ヘッダ同期（0x55, 0xAA）を検出
- タイムアウト（1秒）付き
- 正常なパケットを返す

### `clear_serial_buffer()`

シリアルバッファ内の古いデータをクリア。

```rust
fn clear_serial_buffer(port: &mut dyn SerialPort) -> Result<usize>
```

- 最大100msでバッファをクリア
- クリアしたバイト数を返す

## データフロー図

```
┌─────────────────────────────────┐
│  シリアルポート (COM8 等)       │
│  24バイトバイナリパケット       │
└──────────────┬──────────────────┘
               │ read_packet()
               ↓
┌─────────────────────────────────┐
│  ImuPacket パース               │
│  ・ヘッダ同期検出               │
│  ・シーケンス番号抽出            │
│  ・センサー生データ抽出          │
└──────────────┬──────────────────┘
               │ gyro_to_dps(), accel_to_g()
               ↓
┌─────────────────────────────────┐
│  スケーリング変換               │
│  ・ジャイロ: dps                │
│  ・加速度: G                    │
└──────────────┬──────────────────┘
               │ バイアス補正
               ↓
┌─────────────────────────────────┐
│  姿勢更新                       │
│  update_orientation_quat()     │
│  ・ジャイロ積分                 │
│  ・加速度補正                   │
│  ・コンプリメンタリフィルタ      │
└──────────────┬──────────────────┘
               │
      ┌────────┴────────┐
      │                 │
      ↓                 ↓
┌───────────────┐  ┌───────────────┐
│ 標準出力      │  │ UDP送信       │
│ DATA_Q,...    │  │ DATA,...      │
│ クォータニオン │  │ 回転ベクトル   │
└───────────────┘  └───────────────┘
      ↓                 ↓
   Python            Unity
```

## コマンド

### キャリブレーション

**標準入力経由:**
```
CALIBRATE
```

**UDP経由:**
```bash
echo "CALIBRATE" | nc -u 127.0.0.1 50006
```

キャリブレーション完了時、`CALIBRATION_DONE` が標準出力とUDP両方で通知される。

## 注意事項

1. キャリブレーション中はデバイスを静止させること
2. シリアルポートが見つからない場合、エラーで終了する
3. UDP送信エラーはUnity未起動時に発生するが、警告のみで処理継続
4. 加速度のノルムが 0.5〜1.5G の範囲外の場合、加速度補正はスキップされる
5. `alpha = 0.98` は高周波でジャイロ、低周波で加速度を信頼する設定
